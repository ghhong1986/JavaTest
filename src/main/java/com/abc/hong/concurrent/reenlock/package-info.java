/*
 * Copyright 畅捷通股份有限公司 @ 2015 版权所有
 */
/**
 * <p>
 * 1、ReentrantLock构造函数提供了2种公平性的选择：

1）创建公平锁。如果锁已经被其他线程战友有，新的请求线程会加入到等待队列，或者已经有一些线程在等待锁了。

2）创建非公平锁，线程按顺序请求获得公平锁，而一个非公平锁可以闯入，如果锁的状态可用，请求非公平锁的线
程可在等待队列中向前跳跃，获得该锁。内部锁synchronized没有提供确定的公平性保证

      ReentrantLock是jdk5引入的新的锁机制，它与内部锁（synchronize） 相同的并发性和内存语义，比如可重入
      加锁语义。在中等或者更高负荷下，ReentrantLock有更好的性能，并且拥有可轮询和可定时的请求锁等高级功 
      能。这个程序简单对比了ReentrantLock公平锁、ReentrantLock非公平锁以及内部锁的性能，从结果上看，非公
      平的 ReentrantLock表现最好。内部锁也仅仅是实现统计意义上的公平，结果也比公平的ReentrantLock好上很多。
      这个程序仅仅是计数，启 动N个线程，对同一个Counter进行递增，显然，这个递增操作需要同步以保证原子性，
      采用不同的锁来实现同步，然后查看结果。
 * </p>
 * 
 * @author 洪光华 2015年5月11日<br/>
 */
package com.abc.hong.concurrent.reenlock;


